<style>
    pre.format {
        background-color: #EBEDED;
        margin: 5px;
        padding: 3px;
        border: solid 1px #737370;
        border-radius: 3px;
        --webkit-border-radius: 3px;
        /*width: 166px;*/
    }
</style>

<p>
    Maybe you already hear about a simple, but addictive game 2048
    (read about this <a href="http://en.wikipedia.org/wiki/2048_%28video_game%29">here</a>).
    In this task we will look behind the scenes and try to implement its basic movement functionality.

</p>

<div>
    2048 is played on a simple 4Ã—4 grid with tiles.
    Player can move tiles left, right, up, and down.
    If two tiles of the same number collide while moving,
    they will merge into a tile with the total value of the two tiles that collided.
    The resulting tile cannot merge with another tile again in the same move.
    Every turn, a new tile will appear in the last empty spot (value 0) on the board with a value of either 2
    (here is the difference from the original game).
    The last empty slot is determined by indexes that are defined in the followed order:
    <pre class="format">[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]</pre>

    At the beginning, there's already two numbers on the board.
</div><br>
<p>
    You are given a state of the game as 4x4 matrix with numbers which are powers by 2 and
    player move as a direction (up, down, left, right).
    You should to return the game state after this move.
</p>

<div>
    If the game is won ,i.e. 2048 appears on the board, then return the winning matrix:
    <pre class="format">[['U','W','I','N'], ['U','W','I','N'], ['U','W','I','N'], ['U','W','I','N']]</pre>
    If the game is lose, i.e. nothing change after the player move and there is not a empty spot, then return the losing
    matrix:
    <pre class="format">[['G','A','M','E'], ['O','V','E','R'], ['G','A','M','E'], ['O','V','E','R']]</pre>
</div><br>

<p>
    <strong>Input: </strong> A game state as a list of lists with integers and player's move as a string ('up', 'down',
    'left' or 'right').
</p>

<p>
    <strong>Output: </strong>
    The game state after player's move as a list of lists with integers or letters.
</p>


<p class="for_info_only"><strong>How it is used:</strong>
    This can be used as a bases for further adding GUI to the python version of the 2048 game.
</p>


<div class="for_info_only">
    <p><i></i></p>

    <p>
        <strong>Example:</strong>
    </p>
    <pre class="brush: python">
##example 1
checkio(
    [
        [0,0,0,0],
        [0,64,0,0],
        [0,0,2,0],
        [0,64,0,0]
    ], 'up') == [
        [0,128,2,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,2]
    ]
##example 2
checkio(
    [
        [2,2,2,2],
        [2,2,2,2],
        [2,2,2,2],
        [2,2,2,2]
    ],'left') == [
        [4,4,0,0],
        [4,4,0,0],
        [4,4,0,0],
        [4,4,0,2]
    ]
##example 3
checkio(
    [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [2,2,0,0]
    ],'down') == [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [2,2,0,0]
    ]
##example 4
checkio(
    [
        [0,0,0,2],
        [0,0,0,2],
        [0,0,0,0],
        [0,0,0,0]
    ],'right') == [
        [0,0,0,2],
        [0,0,0,2],
        [0,0,0,0],
        [0,0,0,0]
    ]
##example 5
checkio(
    [
        [0,0,1024,1024],
        [0,0,0,2],
        [0,0,0,0],
        [0,0,0,0]
    ],'right') == [
        ['U','W','I','N'],
        ['U','W','I','N'],
        ['U','W','I','N'],
        ['U','W','I','N']
    ]
    </pre>
</div>


<p><strong>Preconditions: </strong>
    (a)The matrix is always 4*4. (b)The numebers in the matrix are always 0 or 2**n, for all n is positive integer 1~10.
</p>