<style>
    pre.format {
        background-color: #EBEDED;
        margin: 5px;
        padding: 3px;
        border: solid 1px #737370;
        border-radius: 3px;
        --webkit-border-radius: 3px;
        overflow-x: auto;

        /*width: 166px;*/
    }
</style>

<p>
  Возможно вы уже знаете про простую, но затягивающую игру
  2048 (прочитать о ней <a href="http://en.wikipedia.org/wiki/2048_%28video_game%29">на Википедии</a>).
  В этой задаче мы заглянем за сцену и попытаемся повторить функциональность механики игровых ходов.

</p>

<div>
  2048 играется на квадратном поле 4 на 4 с фишками. Игрок может двигать фишки влево, вправо, вверх и вниз.
  Если две фишки совпадают при движении, то они объединяются в фишку со значением равным сумме этих двух.
  Полученная таким образом фишка не может на этот же ход объединится с другой.
  Если у нас 3 фишки с одним значением, то сначала объединяются, те что ближе к краю к которому мы
  двигаем (вправо - значит правый край).
  Каждый ход новая фишка появляется в последней пустой клетке на поле со значением 2.
  Последняя пустая клетка определяется по индексу в следующем порядке:
  <pre class="format for_info_only">[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]</pre>
  <pre class="format for_editor_only" style="width: 380px">[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]</pre>

  В начале игры на поле всегда есть две фишки.
</div><br>
<p>
  Дано игровое поле с фишками, представленное, как матрица 4 на 4 с числами, которые являются степенями 2.
  Игрок делает ход и вам нужно рассчитать, каким будет игровое поле после этого хода.
</p>

<div>
  Если игра закончилась победой игрока, то есть 2048 появилось на поле, то функция должна вернуть
  "победную" матрицу:
  <pre class="format for_info_only">[['U','W','I','N'], ['U','W','I','N'], ['U','W','I','N'], ['U','W','I','N']]</pre>
  <pre class="format for_editor_only" style="width: 380px">[['U','W','I','N'], ['U','W','I','N'], ['U','W','I','N'], ['U','W','I','N']]</pre>
  Если игра закончилась проигрышем, то есть нет пустых мест на поле, то функция должна вернуть
  матрицу "проигрыша":
  <pre class="format for_info_only">[['G','A','M','E'], ['O','V','E','R'], ['G','A','M','E'], ['O','V','E','R']]</pre>
  <pre class="format for_editor_only" style="width: 380px">[['G','A','M','E'], ['O','V','E','R'], ['G','A','M','E'], ['O','V','E','R']]</pre>
</div><br>

<p>
    <strong>Входные данные: </strong>
    Игровое поле, как список (list) списков с целыми числами и ход игрока, как строка
    ('up', 'down', 'left' or 'right').
</p>

<p>
    <strong>Выходные данные: </strong>
    Игровое поле после хода, как список списков с целыми числами или буквами.
</p>


<p class="for_info_only"><strong>Как это используется:</strong>
  Добавьте к этому графическую оболочку и у вас есть полноценная игра.
</p>


<div class="for_info_only">
    <p><i></i></p>

    <p>
        <strong>Примеры:</strong>
    </p>
    <pre class="brush: python">
move2048([[0, 2, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 2, 0, 0]], 'up') == [[0, 4, 0, 0],
                                   [0, 0, 0, 0],
                                   [0, 0, 0, 0],
                                   [0, 0, 0, 2]]
move2048([[4, 0, 0, 0],
          [0, 4, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 8, 8]], 'right') == [[0, 0, 0, 4],
                                      [0, 0, 0, 4],
                                      [0, 0, 0, 0],
                                      [0, 0, 2, 16]]
move2048([[2, 0, 2, 2],
          [0, 4, 4, 4],
          [8, 8, 8, 16],
          [0, 0, 0, 0]], 'right') == [[0, 0, 2, 4],
                                      [0, 0, 4, 8],
                                      [0, 8, 16, 16],
                                      [0, 0, 0, 2]]
move2048([[256, 0, 256, 4],
          [16, 8, 8, 0],
          [32, 32, 32, 32],
          [4, 4, 2, 2]], 'right') == [[0, 0, 512, 4],
                                      [0, 0, 16, 16],
                                      [0, 0, 64, 64],
                                      [0, 2, 8, 4]]
move2048([[4, 4, 0, 0],
          [0, 4, 1024, 0],
          [0, 256, 0, 256],
          [0, 1024, 1024, 8]], 'down') == [['U', 'W', 'I', 'N'],
                                           ['U', 'W', 'I', 'N'],
                                           ['U', 'W', 'I', 'N'],
                                           ['U', 'W', 'I', 'N']]
move2048([[2, 4, 8, 16],
          [32, 64, 128, 256],
          [512, 1024, 2, 4],
          [8, 16, 32, 64]], 'left') == [['G', 'A', 'M', 'E'],
                                        ['O', 'V', 'E', 'R'],
                                        ['G', 'A', 'M', 'E'],
                                        ['O', 'V', 'E', 'R']]</pre>
</div>


<p><strong>Предусловия: </strong>
    len(state) == 4<br>
    all(len(row) == 4 for row in state)<br>
    all(all(x in (0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024) for x in row) for row in state)<br>
</p>
